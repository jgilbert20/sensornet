#!/usr/bin/perl

# To install
# cpan install YAML
# DBD::Pg
# export PATH=$PATH:/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/:/Applications/Xcode.app/Contents/Developer/usr/bin/

# http://www.felixgers.de/teaching/perl/perl_DBI.html

use strict;
use warnings;

$| = 0;

my $timeout = 1;

use POSIX qw(strftime);
use IO::Select;
use IO::Socket; 
use IO::File;
use IO::Handle;

my $BASEDIR   = "/home/pi/sensornet";
my $LOGFN     = "/home/pi/sensornet/mainlog.csv";
my $SLOWLOGFN = "/home/pi/sensornet/slowlog.csv";
my $CONFIGFN  = "/home/pi/sensornet/configuration.txt";
my $DEBUGFN   = "/home/pi/sensornet/debuglog.csv";
my $RAWFN     = "/home/pi/sensornet/raw.txt";
my $NODELOGFN = "/home/pi/sensornet/nodelog.txt";
my $XIVELYFN  = "/tmp/xively.csv";

my %CONFIG;


my %lastSensorValue;
my %lastHeardNode;
my %lastHeardSensor;
my %lastSensorValueOnly;


sub readConfiguration
{
    open C, "<$CONFIGFN" or return;

    while( <C> )
    {
	my $line = $_;
	chomp $line;
	debug( "Parsing line from CONFIG: $line" );
	next if /^\#/;
	my $c = (my( $node, $sensor, $nicename, $varname ) = split( /\t+/, $line ));
	debug( "Has $c elements" );
	next unless $c == 4; 
	debug( "$node-$sensor -> [$nicename,$varname]" );
	$CONFIG{"$node-$sensor"} = [$nicename,$varname];
    }
    
    close C;
}

sub getLogSuffix
{
    my $str = POSIX::strftime( "%Y%m%d", localtime() );
    return $str;
}

my $currentLogSuffix = getLogSuffix();

my $lastNodeLogLine = "";

my $needsHeader = 1 if ! -e $LOGFN;

my $tty = undef; # IO::Handle->new();

my $RPI = 1;

use Time::HiRes qw(gettimeofday);

open( LOGFILE, ">>$LOGFN" ) or die "Cannot open log";
open( DEBUGFILE, ">>$DEBUGFN" ) or die "Cannot open debug log";
open( XIVELY, ">$XIVELYFN" ) or die "Cannot open xively $!";
open( SLOWLOGFILE, ">$SLOWLOGFN" ) or die "Cannot open slow log $!";


my $saveRAW = 0;

if( $saveRAW )
{
    open( RAWFILE, ">>$RAWFN" ) or die "Cannot open log: $!";
}

open( NODELOGFILE, ">>$NODELOGFN" ) or die "Cannot open log: $!";

debug( "SNGateway restarted" );

readConfiguration();


if( $RPI )
{
    # see "http://stackoverflow.com/questions/10362222/test-in-perl-if-data-is-available-on-deviceserialport" for example

    use Device::SerialPort qw( :PARAM :STAT 0.07 );

    use Symbol qw( gensym );
    my $PORT = "/dev/ttyAMA0";

    $tty = gensym();
    my $ob = tie( *$tty, "Device::SerialPort", $PORT );

#    my $ob = Device::SerialPort->new($PORT)  || die "Can't open $PORT: $!\n";
    $ob->baudrate(57600);
    $ob->write_settings;

    debug( "Opening port" );
    
 #   open( TTY, "+</dev/ttyAMA0" ) or die "Cannot open tty";
  #  $tty = *TTY;
}
else
{
    sysopen( $tty , "neep", O_RDWR) or die "Sysopen failed";    
}

if( $needsHeader )
{
    print LOGFILE "TS,Sequence,Node,Millis,Sensor,Reading,ReadingUnits,Memo,RSSI,OriginId,Nicename,Location\n";
}

debug( "Starting listener" );

my $lsn = IO::Socket::INET->new(Listen => 1, LocalPort => 8080) or die "Cannot bind";
my $sel = IO::Select->new( $lsn );
$sel->add( $tty );

debug( "Select loop setup completed" );

my $DB_user    = 'postgres';
my $DB_name    = 'sensor';
my $DB_pwd     = '';

my %taskRegistry;
sub debug
{
	my @arg = @_;

	my ($s,$ms) =
	    gettimeofday();
	
	my $ts = localtime( $s ) ;
	
	my $str = POSIX::strftime( "%Y/%m/%d %H:%M:%S", localtime $s );

	my $msf = sprintf( "%06d", $ms );
	print STDERR "$str.$msf: ";
	print STDERR @arg;
	print STDERR "\n";

	print DEBUGFILE "$str.$msf: ";
	print DEBUGFILE @arg;
	print DEBUGFILE "\n";
	
	DEBUGFILE->flush();


}

#$dbh = DBI->connect("dbi:Pg:dbname=$DB_name","$DB_user","$DB_pwd");

sub logSysStatsLight
{
    open PROC, '</proc/loadavg' or warn "Cannot open loadavg";

    my $line = <PROC>;
    close PROC;

    my( $iLoad, @allElse ) = split /\s+/, $line;

    logLocalSensor( "LoadAverage", $iLoad, "load", "" );

    open MEM, '</proc/meminfo' or warn "cannot open mem";

    while( <MEM> )
    {
    	my( $p, $v, $unit) = split /[\s\:]+/;
    	if( $p eq "MemFree" or $p eq "Active" or $p eq "Cached" )
    	{
    	    logLocalSensor( "Mem-$p", $v / 1024, "MB", "" );
    	}
    }

    close MEM;
}


sub logUptime
{
    my $uptime = `cat /proc/uptime`;
    my ($upsec, $idlesec) = split /\s+/, $uptime;

    logLocalSensor( "Uptime", $upsec, "seconds", "" );
    logLocalSensor( "Idletime", $idlesec, "seconds", "" );

    # note: discovered that /sys/class/thermal/thermal_zone0/temp is the same thing

    debug( "Query temp via vcgencmd - started" );
    
    my $temp = `vcgencmd measure_temp`;

    debug( "Query temp via vcgencmd - completed" );

    $temp =~ /temp=(\d+\.?\d?)/;

    logLocalSensor( "MPU Temp", $1, "C", "" );
    logLocalSensor( "MPU Temp-F", $1 * 9.0 / 5 + 32 , "F", "" );

    debug( "Checking file system" );

    open DFCMD, '/bin/df $BASE|' or warn "could not open DF command";
    my $header = <DFCMD>;
    my $fs = <DFCMD>;
    close DFCMD or warn "Could not close DF command";
    
#Filesystem     1K-blocks    Used Available Use% Mounted on
# rootfs           3749072 2667756    893576  75% /

    my( $filesystem, $tot, $used, $avail, $pct, $tree ) = split /\s+/, $fs;

    $pct =~ s/\%//;

    logLocalSensor( "Disk-Avail", $avail/1000, "M", "" );
    logLocalSensor( "Disk-Percentage", $pct, "%", "" );
}


sub sendTTY
{
    my $cmd = shift;

#    debug( "Sending [gw]" );
    debug( ">>> $cmd" );
    print $tty "$cmd\n";
}


my %sentToUbi;

sub ubihack
{
# curl -XPOST -H 'Content-Type: application/json;' -H 'X-Auth-Token: MRGzWEagPVr2GH67mUD4DFMsEsjs63fVxTao1oP2km8njRT1kE5jsW1Wy3vK' -d '[{"variable": "5462b94a7625427b3e4bceb0", "value": 23}, {"variable": "5265608ef91b2878f05d75ba", "value": 22}]' http://things.ubidots.com/api/v1.6/collections/values
#curl -XPOST -H 'Content-Type: application/json;' -H 'X-Auth-Token: MRGzWEagPVr2GH67mUD4DFMsEsjs63fVxTao1oP2km8njRT1kE5jsW1Wy3vK' -d '{"value": 24}' http://app.ubidots.com/api/v1.6/variables/5462b94a7625427b3e4bceb0/values

    debug( "UBI: Dumping sensors" );
    foreach my $k (sort keys %lastSensorValueOnly )
    {
    	if( exists $CONFIG{$k} )
    	{
    	    my $val = $lastSensorValueOnly{$k} ;
    	    my ($nice,$varkey) = @{$CONFIG{$k}};
    	    next unless defined $varkey;
    	    
    	    my $d = ( $lastHeardSensor{$k} - $sentToUbi{$k} );

    	    debug( "UBI: Found for $k - last sent $sentToUbi{$k} <> $lastHeardSensor{$k} --> [$d]" );
    	    my $g = 60*5;
    	    if( $d <= $g  )
    	    {
    		debug( "UBI: Skipping beacuse $d <= $g -- not enough new data" );
    		next;
    	    }
    	    
    	    my $cmd =  qq^curl -XPOST -H 'Content-Type: application/json;' -H 'X-Auth-Token: MRGzWEagPVr2GH67mUD4DFMsEsjs63fVxTao1oP2km8njRT1kE5jsW1Wy3vK' -d '[{"variable": "$varkey", "value": $val} ]' http://things.ubidots.com/api/v1.6/collections/values^;

    	    
    	    debug ("UBI: $cmd" );
    	    `$cmd`;
    	    debug( "Result: at:$@ q:$?" );
    	    
    	    $sentToUbi{$k} = time();
    	    
    	}
    }
}

sub updateNodes
{
    sendTTY( "gwup");
}

registerTask( "uptime", 60, sub { logUptime() } ); 

registerTask( "ubihack", 30 , sub { ubihack() } ); 

registerTask( "configuration", 120, sub { readConfiguration() } ); 

registerTask( "lightStats", 20, sub { logSysStatsLight() } ); 

registerTask( "rotateLogs", 300, sub { rotateLogs() } ); 

registerTask( "updatenodes", 10, sub { updateNodes() } ); 

#registerTask( "xively", 30, sub { relayToXively() } ); 

registerTask( "relay-readings", 60, sub { relayReadings() } ); 

registerTask( "writehtml", 60, sub { updateHTML() } ); 

#registerTask( "dumpps", 50, sub { `mkdir -p pslog`; 
#				  `date >> uplog.txt`;
#				  `uptime >> uplog.txt`;
#				  `vcgencmd measure_temp >> uplog.txt`;
#	      } );

sub rotateLogs()
{
    debug( "rotate: Checking for log rotation..." );

    if( $currentLogSuffix ne getLogSuffix() )
    {
    	debug( "rotate: verifying path" );
    	`mkdir $BASEDIR/log-archive`;
    	debug( "rotate: Closing existing logfile" );
    	close DEBUGFILE;
    	`mv $DEBUGFN $BASEDIR/log-archive/debuglog.csv-$currentLogSuffix`;
    	open( DEBUGFILE, ">>$DEBUGFN" ) or die "Cannot open debug log for rotate: $!";
    	debug( "rotate: New logfile started! old: $BASEDIR/log-archive/$DEBUGFN-$currentLogSuffix" );

    	$currentLogSuffix = getLogSuffix();
    }
}

sub registerTask
{
	my $tName = shift;
	my $interval = shift;
	my $code = shift;

	$taskRegistry{$tName} = [$interval, 0, $code, $tName];
}

sub runScheduledTasks
{
   # debug "Housekeeping -- Event recv";	
    
    foreach my $n (keys %taskRegistry)
    {
    	my $t = $taskRegistry{$n};
    	
    	# debug( "Checking task $n -> @$t");
    	if( time() - $t->[1] >  $t->[0] )
    	{		
    	    debug( "Task [$t->[3]] has come due..");
    	    
    	    $t->[1] = time();
    	    &{$t->[2]};
    	}
    }
}


my %runStats;

my $lastRun = [0,0];

debug( "Beginning lisen loop:" );

while(1)
{
    my @ready = $sel->can_read( $timeout );
    
	

	foreach my $fh (@ready) 
	{
	    if($fh == $lsn) 
	    {
                # Create a new socket
                my $new = $lsn->accept;
                $sel->add($new);
                print STDOUT "Accepted new connection from XXX\n";
                syswrite( $new, "Welcome to SensorMonitor");
            }
            elsif( $fh == $tty )
            {	
            	my $in;		
            	my $b = sysread( $fh, $in, 1000);
            	$runStats{"TTY_BYTES_READ"} += $b;  
            	handleTTYDataPacket( $in );	
            }
            else {
                # Process socket
                # Maybe we have finished with the socket
                my $in;
                sysread( $fh, $in, 1000);

                debug "Got data from socket: [$in]";

                syswrite( $fh, "Bye");
                $sel->remove($fh);
                $fh->close;
            }
        }
	
	my $elapsed = Time::HiRes::tv_interval ( $lastRun, [Time::HiRes::gettimeofday]);
#	print "Elapsed $elapsed\n"; 

	if( $elapsed > 1.00 )
	{
        runScheduledTasks();
	    $lastRun = [Time::HiRes::gettimeofday];
	}
}

my $ttyBuffer = "";

#use IO::Scalar;
# $TTY_INTERNAL = new IO::Scalar \$ttyBuffer;

sub handleTTYLine
{
    my $line = shift;
    
    my $date = strftime("%Y-%m-%d %H:%M:%S", localtime(time));
    
    $runStats{"TTY_MSG_READ"} += 1;  
    
    # debug( "<<< TTY $line");
    
    if( $saveRAW )
    {
	   print RAWFILE "$line\n";
    }
    
    $line =~ s/[\r\n]+\Z//;
    
    # Handle regular "R" data lines

    if( $line =~ /^R/ )
    {
    	my @a = split( ',', $line);
    	
    	my $fCount= 0 + @a;
    	if( $fCount != 9 	)
    	{	
    	    debug "Error - [$fCount] wrong number of commas, skipping: offending line is [$line]\n";
    	    $runStats{"TTY_MSG_READ_ERROR"} += 1; 
    	    return;	
    	}
    	
    	$runStats{"TTY_MSG_READ_GOOD"} += 1; 
    	
    	my ( $sequence, $node,	$millis, $sensor, $reading, $readingUnits, $memo, $RSSI, $originId ) = @a;
    	
    	logSensor( @a );
    	
    	$runStats{"NODE_$(node)_MSG_CNT"} += 1; 
    	
    	# Automatically add extra lines converting a C reading to F 
    	
    	if( $readingUnits eq 'C' )
    	{
    	    $sensor .= "-F";
    	    $readingUnits = "F";
    	    $reading =  9/5 *($reading) +32;
    	    
    	    logSensor( $sequence, $node,      $millis, $sensor, $reading, $readingUnits, $memo, $RSSI, $originId );
    	}
    }
    elsif( $line =~ /^L/ )
    {
    	my $date = strftime("%Y-%m-%d %H:%M:%S", localtime(time));
    	my $m = $line;
    	$m =~ s/^L//;
    	if( $m ne $lastNodeLogLine )
    	{
    	    print NODELOGFILE join(',', ($date,$m));
    	    print NODELOGFILE "\n";
    	    flush NODELOGFILE;
    	    $lastNodeLogLine = $m;
    	}
    }
    elsif( $line =~ /^D/ )
    {
        # skip debug lines
    }
    else
    {
    	debug( "<<< UNPROCESSED:" . $line );
    }
}

my $localSequence = 0;

sub logLocalSensor
{
    my ($sensor, $reading, $readingUnits, $memo ) = @_;

    logSensor( $localSequence++, "Gateway-Linux", 1, $sensor, $reading, $readingUnits, $memo, "","" );
}


sub relayToXively
{
    `curl --request PUT --header "X-ApiKey: 2SZfjyyJOp1lguxlmD15ZCfPn0h1E7PO36HlPfJd0g8mCCyb" --data-binary @/tmp/xively.csv --verbose https://api.xively.com/v2/feeds/665513493.csv`;

    close XIVELY;
    open XIVELY, ">$XIVELYFN" or warn "Cannot reopen xively file: $!"; 
}

my %lastPlacedInSlowLog;

sub logSensor
{
    my ( $sequence, $node, $millis, $sensor, $reading, $readingUnits, $memo, $RSSI, $originId ) = @_;
    my $date = strftime("%Y-%m-%d %H:%M:%S", localtime(time));
    my $nice = "";
    my $loc = "";
    chomp $originId;
    my $line = join ",", ($date, $sequence, $node, $millis, $sensor, $reading, $readingUnits, $memo, $RSSI, $originId, $nice, $loc);
    print LOGFILE "$line\n";
    flush LOGFILE; 
    
    my $xively_date = strftime("%Y-%m-%dT%H:%M:%SZ", localtime(time));

    my $xname ="$node-$sensor";

    $xname =~ s/\s+/\-/g;

    if( $xname =~ /BATT-V|Temp-F|LUX|-Pressure/ )
    {
	print XIVELY "$xname,$xively_date,$reading\n";
    }

    if( time() - $lastPlacedInSlowLog{$xname} > 5*60 )
    {
        print SLOWLOGFILE "$line\n";
        $lastPlacedInSlowLog{$xname} = time();
    }

    $lastSensorValue{"$node-$sensor"} = $reading . $readingUnits;
    $lastSensorValueOnly{"$node-$sensor"} = $reading;
    $lastHeardNode{$node} = time();
    $lastHeardSensor{"$node-$sensor"} = time();
}


sub updateHTML
{
    return();

    `mkdir -p $BASEDIR/www`;
    open FILE, ">$BASEDIR/www/sensors.txt" or die "cannot write to file";

    foreach my $k (sort keys %lastSensorValue )
    {
    my $l = time() - $lastHeardSensor{$k};
    print FILE sprintf( "%-30s %-20s (%4d ago)",   $k,$lastSensorValue{$k}, $l );

    }
close FILE;



        open FILE, ">$BASEDIR/www/nodes.txt" or die "cannot write to file";


    foreach my $k (sort keys %lastHeardNode )
    {
       my $l = time() - $lastHeardNode{$k} ;
       print FILE "$k -> $l seconds ago";
    }
    
close FILE;

}


sub relayReadings
{
    debug( "Dumping sensors" );
    foreach my $k (sort keys %lastSensorValue )
    {
	my $l = time() - $lastHeardSensor{$k};
      

	next if $lastSensorValue{$k} =~ /C$/;

#	debug( "   $k -> $lastSensorValue{$k} ($l sec. ago)" );
	debug( sprintf( "%-30s %-20s (%4d ago)",   $k,$lastSensorValue{$k}, $l ));

    }

    debug( "Dumping nodes" );
    foreach my $k (sort keys %lastHeardNode )
    {
	   my $l = time() - $lastHeardNode{$k} ;
	   debug( "   $k -> $l seconds ago" );
    }


}

sub  handleTTYDataPacket
{
	my $data = shift;

	# debug( "Adding to TTY buffer:[$data]");
	$ttyBuffer .= $data;

	while( (my $nextNL = index( $ttyBuffer, "\n",0 )) != -1 )
	{
		# debug "Newline detected at position [$nextNL]"; # in [$ttyBuffer]";
		my $nextline = substr( $ttyBuffer, 0, $nextNL + 1 );
		substr( $ttyBuffer, 0, $nextNL + 1, "" );
		chomp $nextline;

		handleTTYLine( $nextline ) if( length $nextline > 0 );
	}
}

END: 
{
	debug "Shutting down...";
	$lsn->close();
} 




